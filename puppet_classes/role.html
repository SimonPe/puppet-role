<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>
  Puppet Class: role
  
    &mdash; Documentation by YARD 0.9.20
  
</title>

  <link rel="stylesheet" href="../css/style.css" type="text/css" charset="utf-8" />

  <link rel="stylesheet" href="../css/common.css" type="text/css" charset="utf-8" />

<script type="text/javascript" charset="utf-8">
  pathId = "puppet_classes::role";
  relpath = '../';
</script>


  <script type="text/javascript" charset="utf-8" src="../js/jquery.js"></script>

  <script type="text/javascript" charset="utf-8" src="../js/app.js"></script>


  </head>
  <body>
    <div class="nav_wrap">
      <iframe id="nav" src="../puppet_class_list.html?1"></iframe>
      <div id="resizer"></div>
    </div>

    <div id="main" tabindex="-1">
      <div id="header">
        <div id="menu">
  
    <a href="../_index.html">Index (r)</a> &raquo;
    <span class='title'><span class='object_link'>Puppet Classes</span></span>
     &raquo; 
    <span class="title">role</span>
  
</div>

        <div id="search">
  
    <a class="full_list_link" id="puppet_class_list_link"
        href="../puppet_class_list.html">

        <svg width="24" height="24">
          <rect x="0" y="4" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="12" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="20" width="24" height="4" rx="1" ry="1"></rect>
        </svg>
    </a>
  
</div>
        <div class="clear"></div>
      </div>

      <div id="content"><h1>Puppet Class: role</h1>
<div class="box_info">
  
  
  <dl>
    <dt>Defined in:</dt>
    <dd>
      manifests/init.pp
    </dd>
  </dl>
</div>

<h2>Overview</h2>
<div class="docstring">
  <div class="discussion">
    <p>Assigns the correct role to each node.</p>

<p>It acts as a proxy which allows you to store your roles in a different namespaced
module. For a single host, you can also use a specific configuration (upstream / shared
roles and profiles).</p>

<p>To get started, you should define the namespace (or search_namespaces) to use.</p>

  </div>
</div>


<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>namespace</span>
      
      
        <span class='type'>(<tt>Optional[String]</tt>)</span>
      
      
        <em class="default">(defaults to: <tt>undef</tt>)</em>
      
      
        &mdash;
        <div class='inline'><p>The module namespace that holds your roles. If you are not using namespaces and map
roles directly to class names, make this an empty string (&#39;&#39;).</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>search_namespaces</span>
      
      
        <span class='type'>(<tt>Optional[Array[Role::SearchNamespace]]</tt>)</span>
      
      
        <em class="default">(defaults to: <tt>undef</tt>)</em>
      
      
        &mdash;
        <div class='inline'><p>A list of namespaces to search. If using this, we will attempt to find the
first existing role in order. If no match is found, the puppet run will fail.</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>separator</span>
      
      
        <span class='type'>(<tt>String</tt>)</span>
      
      
        <em class="default">(defaults to: <tt>&#39;::&#39;</tt>)</em>
      
      
        &mdash;
        <div class='inline'><p>Anything to put in between the namespace and the role.</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>resolve_order</span>
      
      
        <span class='type'>(<tt>Variant[Role::ResolveMethod, Array[Role::ResolveMethod]]</tt>)</span>
      
      
        <em class="default">(defaults to: <tt>[&#39;param&#39;, &#39;default&#39;]</tt>)</em>
      
      
        &mdash;
        <div class='inline'><p>The order in which we will be looking for the correct
role to use. Currently supported values are:</p>

<ul>
<li><code>trusted</code>: Use a trusted fact. The name must be configured using <code>trusted_extension_name</code>.</li>
<li><code>fact</code>: Use a fact. The name must be configured using <code>fact_name</code>.</li>
<li><code>param</code>: Uses the provided <code>role</code> parameter. This can also be used to configure using hiera.</li>
<li><code>callback</code>: Use a function callback. The function must be configured using <code>function_callback_name</code>.</li>
<li><code>default</code>: Fall back to the default value. You would typically put this after other methods.</li>
<li><code>fail</code>: Fail the run if this method is reached. This enforces setting up a role and skips using the default role.</li>
</ul>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>role</span>
      
      
        <span class='type'>(<tt>Optional[String[1]]</tt>)</span>
      
      
        <em class="default">(defaults to: <tt>undef</tt>)</em>
      
      
        &mdash;
        <div class='inline'><p>The role this node should get.</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>trusted_extension_name</span>
      
      
        <span class='type'>(<tt>Optional[String[1]]</tt>)</span>
      
      
        <em class="default">(defaults to: <tt>undef</tt>)</em>
      
      
        &mdash;
        <div class='inline'><p>Name of the trusted fact (extension).</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>fact_name</span>
      
      
        <span class='type'>(<tt>Optional[String[1]]</tt>)</span>
      
      
        <em class="default">(defaults to: <tt>undef</tt>)</em>
      
      
        &mdash;
        <div class='inline'><p>Name of the fact that contains the role.</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>function_callback_name</span>
      
      
        <span class='type'>(<tt>Optional[String[1]]</tt>)</span>
      
      
        <em class="default">(defaults to: <tt>undef</tt>)</em>
      
      
        &mdash;
        <div class='inline'><p>A function that returns the role.</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>translate_role_callback</span>
      
      
        <span class='type'>(<tt>Variant[Undef, String[1], Hash]</tt>)</span>
      
      
        <em class="default">(defaults to: <tt>undef</tt>)</em>
      
      
        &mdash;
        <div class='inline'><p>Optionally, a function name that should be used or a map with gsubstr tuples.</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>default_role</span>
      
      
        <span class='type'>(<tt>String</tt>)</span>
      
      
        <em class="default">(defaults to: <tt>&#39;default&#39;</tt>)</em>
      
      
        &mdash;
        <div class='inline'><p>the default role to assume. Used when no resolve method provides a result.</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>default_namespace</span>
      
      
        <span class='type'>(<tt>String</tt>)</span>
      
      
        <em class="default">(defaults to: <tt>&#39;::role&#39;</tt>)</em>
      
      
        &mdash;
        <div class='inline'><p>namespace to use if the default is used.</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>default_separator</span>
      
      
        <span class='type'>(<tt>String</tt>)</span>
      
      
        <em class="default">(defaults to: <tt>&#39;::&#39;</tt>)</em>
      
      
        &mdash;
        <div class='inline'><p>separator to use if the default is used.</p>
</div>
      
    </li>
  
</ul>


</div><div class="method_details_list">
  <table class="source_code">
    <tr>
      <td>
        <pre class="lines">


33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147</pre>
      </td>
      <td>
        <pre class="code"><span class="info file"># File 'manifests/init.pp', line 33</span>

class role (
  Optional[String] $namespace = undef,
  String $separator = &#39;::&#39;,
  Variant[Role::ResolveMethod, Array[Role::ResolveMethod]] $resolve_order = [&#39;param&#39;, &#39;default&#39;],

  Optional[String[1]] $role                   = undef,
  Optional[String[1]] $trusted_extension_name = undef,
  Optional[String[1]] $fact_name              = undef,
  Optional[String[1]] $function_callback_name = undef,
  Variant[Undef, String[1], Hash] $translate_role_callback = undef,

  Optional[Array[Role::SearchNamespace]] $search_namespaces = undef,

  String $default_role      = &#39;default&#39;,
  String $default_namespace = &#39;::role&#39;,
  String $default_separator = &#39;::&#39;,
) {

  # Check if the required &#39;configuration&#39; is present
  if &#39;trusted&#39; in $resolve_order {
    assert_type(String[1], $trusted_extension_name)
  }
  if &#39;fact&#39; in $resolve_order {
    assert_type(String[1], $fact_name)
  }
  if &#39;callback&#39; in $resolve_order {
    assert_type(String[1], $function_callback_name)
  }
  unless $namespace or ($search_namespaces and size($search_namespaces) &gt; 0) {
    fail(&#39;Either namespace or a not empty search_namespaces must be provided.&#39;)
  }

  $resolve_array = [$resolve_order].flatten.map |String $method| {
    case $method {
      &#39;param&#39; : {
        if $role {
          $resolved = $role
        }
        else {
          $resolved = undef
        }
      }
      &#39;fact&#39;: {
        if $fact_name and has_key($::facts, $fact_name) {
          $resolved = $::facts[$fact_name]
        }
        else {
          $resolved = undef
        }
      }
      &#39;callback&#39;: {
        if $function_callback_name {
          $resolved = call($function_callback_name)
        }
        else {
          $resolved = undef
        }
      }
      &#39;trusted&#39;: {
        if $trusted_extension_name and has_key($::trusted[&#39;extensions&#39;], $trusted_extension_name) {
          $resolved = $::trusted[&#39;extensions&#39;][$trusted_extension_name]
        }
        else {
          $resolved = undef
        }
      }
      &#39;fail&#39;: {
        $tried = $resolve_order.reduce([]) |$tries, $method| {
          if ($method == &#39;fail&#39;) { break() }
          $tries + $method
        }.join(&#39;, &#39;)
        fail(&quot;Unable to resolve a role and hard failure requested. Attempted methods: ${tried}.&quot;)
      }
      default: {
        $resolved = undef
        break()
      }
    }
    $resolved
  }.filter |$value| { $value =~ NotUndef }

  # Nothing was resolved.
  if size($resolve_array) == 0 {
    include &quot;${default_namespace}${default_separator}${default_role}&quot;
  } else {
    $resolved = $translate_role_callback ? {
      undef   =&gt; $resolve_array[0],
      Hash    =&gt; role::translate_with_map($resolve_array[0], $translate_role_callback),
      default =&gt; call($translate_role_callback, $resolve_array[0]),
    }

    # namespace was provided.
    if $namespace {
      include &quot;${namespace}${separator}${resolved}&quot;
    }
    # search_namespaces
    else {
      # sanitize the array with namespaces
      $search = role::expand_search_namespaces($separator, $search_namespaces)
      # find roles with a class that actually exists
      $existing_roles = $search.map |String $space, String $separator| {
        $rolename = &quot;${space}${separator}${resolved}&quot;
        if defined($rolename) { $rolename }
        else { false }
      }.filter |$val| {
        $val =~ String
      }
      if size($existing_roles) &gt; 0 {
        include $existing_roles[0]
      } else {
        fail(&quot;Requested role &#39;${resolved}&#39; not found on any of the search namespaces.&quot;)
      }
    }
  }
}</pre>
      </td>
    </tr>
  </table>
</div>
</div>

      <div id="footer">
     Generated by <a href="http://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>.
</div>

    </div>
  </body>
</html>